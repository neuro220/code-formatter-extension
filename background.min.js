/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 955:
/***/ (() => {


;// CONCATENATED MODULE: ./src/utils/mimeTypeDetection.ts
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) { n[e] = r[e]; } return n; }
// Universal MIME type to language mapping
// Handles various MIME type variations for the same content type
var mimeTypeMappings = [
// JavaScript and variants
{
  patterns: [/^(application|text)\/(x-)?javascript$/i, /^application\/(x-)?ecmascript$/i, /^text\/ecmascript$/i, /^text\/jscript$/i],
  language: 'js'
},
// JSON
{
  patterns: [/^application\/json$/i, /^text\/json$/i, /^application\/([\w.-]+\+)?json$/i // Handles variations like application/ld+json
  ],
  language: 'json'
},
// CSS
{
  patterns: [/^text\/css$/i],
  language: 'css'
},
// XML and variants
{
  patterns: [/^(application|text)\/xml$/i, /^application\/([\w.-]+\+)?xml$/i, /^text\/xml-external-parsed-entity$/i],
  language: 'xml'
},
// HTML (to exclude from formatting)
{
  patterns: [/^text\/html$/i, /^application\/xhtml\+xml$/i],
  language: 'html'
},
// PHP
{
  patterns: [/^(application|text)\/x-php$/i, /^application\/x-httpd-php$/i, /^text\/php$/i],
  language: 'php'
},
// Python
{
  patterns: [/^(text|application)\/x-python$/i, /^text\/plain$/i // When combined with .py extension
  ],
  language: 'py'
},
// YAML
{
  patterns: [/^(text|application)\/x-yaml$/i, /^text\/yaml$/i, /^application\/yaml$/i],
  language: 'yaml'
},
// Markdown
{
  patterns: [/^text\/markdown$/i, /^text\/x-markdown$/i],
  language: 'md'
},
// SQL
{
  patterns: [/^(application|text)\/x-sql$/i, /^text\/sql$/i],
  language: 'sql'
},
// TypeScript
{
  patterns: [/^(text|application)\/typescript$/i, /^text\/x-typescript$/i],
  language: 'ts'
},
// Plain text (as fallback)
{
  patterns: [/^text\/plain$/i],
  language: 'text'
}];
// Extension to common MIME types mapping
// This simulates what servers typically send for these extensions
var extensionToMimeTypes = {
  // JavaScript variations
  'js': ['application/javascript', 'application/x-javascript', 'text/javascript'],
  'mjs': ['application/javascript', 'text/javascript'],
  'jsx': ['text/jsx', 'application/javascript'],
  // TypeScript
  'ts': ['application/typescript', 'text/typescript'],
  'tsx': ['text/tsx', 'application/typescript'],
  // JSON
  'json': ['application/json', 'text/json'],
  'jsonld': ['application/ld+json'],
  'geojson': ['application/geo+json'],
  // CSS
  'css': ['text/css'],
  'less': ['text/less', 'text/css'],
  'sass': ['text/sass', 'text/css'],
  'scss': ['text/scss', 'text/css'],
  // XML variations
  'xml': ['application/xml', 'text/xml'],
  'xsl': ['application/xml', 'text/xml'],
  'xslt': ['application/xslt+xml'],
  'svg': ['image/svg+xml'],
  'rss': ['application/rss+xml'],
  // HTML
  'html': ['text/html'],
  'htm': ['text/html'],
  'xhtml': ['application/xhtml+xml'],
  // PHP
  'php': ['application/x-httpd-php', 'text/x-php'],
  'phtml': ['application/x-httpd-php'],
  // Python
  'py': ['text/x-python', 'application/x-python'],
  'pyw': ['text/x-python'],
  // Ruby
  'rb': ['text/x-ruby', 'application/x-ruby'],
  // Go
  'go': ['text/x-go', 'application/x-go'],
  // Rust
  'rs': ['text/x-rust', 'application/x-rust'],
  // Java
  'java': ['text/x-java', 'application/x-java'],
  // C/C++
  'c': ['text/x-c', 'text/plain'],
  'cpp': ['text/x-c++', 'text/plain'],
  'cc': ['text/x-c++', 'text/plain'],
  'cxx': ['text/x-c++', 'text/plain'],
  'h': ['text/x-c', 'text/plain'],
  'hpp': ['text/x-c++', 'text/plain'],
  // C#
  'cs': ['text/x-csharp', 'application/x-csharp'],
  // Shell scripts
  'sh': ['application/x-sh', 'text/x-shellscript'],
  'bash': ['application/x-sh', 'text/x-shellscript'],
  // YAML
  'yaml': ['text/yaml', 'application/x-yaml'],
  'yml': ['text/yaml', 'application/x-yaml'],
  // Markdown
  'md': ['text/markdown', 'text/x-markdown'],
  'markdown': ['text/markdown', 'text/x-markdown'],
  // SQL
  'sql': ['application/sql', 'text/x-sql'],
  // Configuration files
  'ini': ['text/plain'],
  'conf': ['text/plain'],
  'config': ['text/plain'],
  // Other
  'txt': ['text/plain'],
  'log': ['text/plain']
};
/**
 * Get the most likely MIME types for a file extension
 */
function getMimeTypesForExtension(extension) {
  var ext = extension.toLowerCase();
  return extensionToMimeTypes[ext] || ['text/plain'];
}
/**
 * Detect language from MIME type string
 */
function detectLanguageFromMimeType(mimeType) {
  var _iterator = _createForOfIteratorHelper(mimeTypeMappings),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var mapping = _step.value;
      var _iterator2 = _createForOfIteratorHelper(mapping.patterns),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var pattern = _step2.value;
          if (pattern.test(mimeType)) {
            return mapping.language;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return null;
}
/**
 * Enhanced language detection combining extension and MIME type knowledge
 */
function detectLanguageWithMimeTypeKnowledge(extension) {
  // First, get possible MIME types for this extension
  var possibleMimeTypes = getMimeTypesForExtension(extension);
  // Try to detect language from each possible MIME type
  var _iterator3 = _createForOfIteratorHelper(possibleMimeTypes),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var mimeType = _step3.value;
      var detectedLang = detectLanguageFromMimeType(mimeType);
      if (detectedLang && detectedLang !== 'text' && detectedLang !== 'html') {
        return detectedLang;
      }
    }
    // If no language detected from MIME types, return the extension itself
    // This maintains backward compatibility
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  return extension;
}
/**
 * Check if content might be JSON based on common API URL patterns
 */
function mightBeJsonFromUrl(url) {
  var jsonUrlPatterns = [/\/api\//i, /\/v\d+\//i, /\.json($|\?)/i, /\/json\//i, /format=json/i, /content-type=json/i, /\/rest\//i, /\/graphql/i, /\/wp-json\//i, /\/wp\/v\d+\//i, /\/(data|config|settings|manifest)($|\/|\?)/i, /\.api($|\/|\?)/i, /\/ajax\//i, /\/endpoint\//i, /\/service\//i, /\/rpc\//i, /accept=.*json/i, /response.*json/i, /output=json/i, /type=json/i // Type parameter
  ];
  return jsonUrlPatterns.some(function (pattern) {
    return pattern.test(url);
  });
}
;// CONCATENATED MODULE: ./src/background.ts

chrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {
  // Check if tab.url exists before testing it
  if (changeInfo.status === 'complete' && tab.url && /^(http|file|data)/.test(tab.url)) {
    // Check if tab.id exists before using it
    if (typeof tab.id === 'undefined') {
      //console.error("Tab ID is undefined.");
      return;
    }
    // Check tab.url again for the URL constructor (although already checked by regex)
    if (!tab.url) {
      //console.error("Tab URL is undefined after regex check?"); // Should not happen
      return;
    }
    // Enhanced language detection
    var programmingLanguage = '';
    // Check if it's a data URL
    if (tab.url.startsWith('data:')) {
      // Parse data URL: data:[<mediatype>][;base64],<data>
      var dataUrlMatch = tab.url.match(/^data:([^;,]+)(;base64)?,(.*)$/);
      if (dataUrlMatch) {
        var mimeType = dataUrlMatch[1];
        var isBase64 = !!dataUrlMatch[2];
        // Map common MIME types to languages
        if (mimeType.includes('javascript') || mimeType.includes('ecmascript')) {
          programmingLanguage = 'js';
        } else if (mimeType.includes('json')) {
          programmingLanguage = 'json';
        } else if (mimeType.includes('css')) {
          programmingLanguage = 'css';
        } else if (mimeType.includes('xml')) {
          programmingLanguage = 'xml';
        } else if (mimeType.includes('html')) {
          programmingLanguage = 'html';
        } else {
          programmingLanguage = 'auto-detect';
        }
        // Store base64 flag in the message
        programmingLanguage = programmingLanguage + (isBase64 ? ':base64' : '');
      }
    } else {
      // Regular URL handling
      var url = new URL(tab.url);
      var pathname = url.pathname;
      var possibleExtension = pathname.split('.').pop() || '';
      // Check if we have a file extension
      if (possibleExtension && pathname.includes('.')) {
        programmingLanguage = detectLanguageWithMimeTypeKnowledge(possibleExtension);
      } else if (mightBeJsonFromUrl(tab.url)) {
        // No extension but URL pattern suggests JSON
        programmingLanguage = 'json';
      } else {
        // For URLs without extensions, let content script decide based on content
        // This handles cases where we can't determine from URL alone
        programmingLanguage = 'auto-detect';
      }
    }
    // Always proceed - let content script make final decision
    // console.log('[Code Formatter BG] Programming language hint:', programmingLanguage, 'for URL:', tab.url);
    chrome.scripting.executeScript({
      target: {
        tabId: tab.id,
        frameIds: [0]
      },
      files: ["./content.min.js"]
    }, function (injectionResults) {
      // Check if script was successfully injected
      if (chrome.runtime.lastError) {
        // console.log('Script injection failed:', chrome.runtime.lastError.message);
        return;
      }
      // Ensure tab.id is defined and injection was successful
      if (typeof tab.id !== 'undefined' && injectionResults && injectionResults.length > 0) {
        // Add a small delay to ensure content script is ready
        setTimeout(function () {
          chrome.tabs.sendMessage(tab.id, {
            programmingLanguage: programmingLanguage
          }, function (response) {
            // Handle any errors in message sending
            if (chrome.runtime.lastError) {
              // This is normal if the content script decides not to format the page
              // console.log('Message sending failed:', chrome.runtime.lastError.message);
            }
          });
        }, 100);
      }
    });
    chrome.scripting.insertCSS({
      target: {
        tabId: tab.id,
        frameIds: [0]
      },
      files: ["./css/content.min.css"]
    }).then(function () {
      // console.log("CSS injected successfully");
    })["catch"](function (err) {
      // console.log("CSS injection failed:", err);
    });
  }
});

/***/ }),

/***/ 888:
/***/ (() => {

// extracted by mini-css-extract-plugin


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			115: 0,
/******/ 			30: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkawps"] = self["webpackChunkawps"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, [30], () => (__webpack_require__(955)))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, [30], () => (__webpack_require__(888)))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;